<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Simple SPH Fluid Simulation (CPU)</title>
<style>
  body {
    margin: 0; overflow: hidden;
    background: white;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: white;
    border: 1px solid black;
  }
</style>
</head>
<body>
<canvas id="canvas" width="600" height="600"></canvas>
<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const NUM_PARTICLES = 300;
  const PARTICLE_RADIUS = 5;

  // SPH parameters
  const h = 0.05; // smoothing radius in normalized coords
  const mass = 1;
  const restDensity = 2000;
  const stiffness = 2000;
  const viscosity = 10000;
  const gravity = 0; // pixels/s^2 approx

  // Time step in seconds
  const dt = 0.0001;

  // Particle structure
  class Particle {
    constructor(x, y) {
      this.x = x;        // position in normalized coords (0..1)
      this.y = y;
      this.vx = 0;       // velocity in normalized units/s
      this.vy = 0;
      this.ax = 0;       // acceleration
      this.ay = 0;
      this.density = 0;
      this.pressure = 0;
    }
  }

  // Initialize particles randomly inside [0.1,0.9] box to avoid boundary issues
  const particles = [];
  for (let i=0; i<NUM_PARTICLES; i++) {
    particles.push(new Particle(
      0.1 + 0.8 * Math.random(),
      0.1 + 0.8 * Math.random()
    ));
  }

  // Kernel functions
  function poly6Kernel(r, h) {
    if (r >= 0 && r <= h) {
      let x = (h*h - r*r);
      return 315 / (64 * Math.PI * Math.pow(h, 9)) * x*x*x;
    }
    return 0;
  }

  function spikyGradKernel(rVec, r, h) {
    if (r > 0 && r <= h) {
      const coeff = -45 / (Math.PI * Math.pow(h, 6)) * (h - r) * (h - r);
      return { x: coeff * (rVec.x / r), y: coeff * (rVec.y / r) };
    }
    return { x: 0, y: 0 };
  }

  function viscosityLapKernel(r, h) {
    if (r >= 0 && r <= h) {
      return 45 / (Math.PI * Math.pow(h, 6)) * (h - r);
    }
    return 0;
  }

  // Mouse interaction to push particles
  let mouseX = 0.5, mouseY = 0.5;
  let mouseDown = false;
  canvas.addEventListener('mousedown', e => {
    mouseDown = true;
    updateMousePos(e);
  });
  canvas.addEventListener('mouseup', e => {
    mouseDown = false;
  });
  canvas.addEventListener('mousemove', e => {
    if(mouseDown) updateMousePos(e);
  });
  function updateMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    mouseX = (e.clientX - rect.left) / rect.width;
    mouseY = (e.clientY - rect.top) / rect.height;
  }

  function computeDensityPressure() {
    for(let i=0; i<NUM_PARTICLES; i++) {
      let pi = particles[i];
      let density = 0;
      for(let j=0; j<NUM_PARTICLES; j++) {
        let pj = particles[j];
        let dx = pj.x - pi.x;
        let dy = pj.y - pi.y;
        let r = Math.sqrt(dx*dx + dy*dy);
        density += mass * poly6Kernel(r, h);
      }
      pi.density = density;
      pi.pressure = stiffness * (density - restDensity);
    }
  }

  function computeForces() {
    for(let i=0; i<NUM_PARTICLES; i++) {
      let pi = particles[i];
      let pressureForceX = 0;
      let pressureForceY = 0;
      let viscosityForceX = 0;
      let viscosityForceY = 0;

      for(let j=0; j<NUM_PARTICLES; j++) {
        if(i === j) continue;
        let pj = particles[j];
        let dx = pj.x - pi.x;
        let dy = pj.y - pi.y;
        let r = Math.sqrt(dx*dx + dy*dy);
        if(r < h && r > 0) {
          let grad = spikyGradKernel({x: dx, y: dy}, r, h);
          let pressTerm = (pi.pressure + pj.pressure) / (2 * pj.density);
          pressureForceX += -mass * pressTerm * grad.x;
          pressureForceY += -mass * pressTerm * grad.y;

          let velDiffX = pj.vx - pi.vx;
          let velDiffY = pj.vy - pi.vy;
          let lap = viscosityLapKernel(r, h);
          viscosityForceX += viscosity * mass * (velDiffX / pj.density) * lap;
          viscosityForceY += viscosity * mass * (velDiffY / pj.density) * lap;
        }
      }

      // Mouse push force if close
      if(mouseDown) {
        let dx = pi.x - mouseX;
        let dy = pi.y - mouseY;
        let dist = Math.sqrt(dx*dx + dy*dy);
        let pushRadius = 0.1;
        let pushForce = 5;
        if(dist < pushRadius && dist > 0) {
          let force = pushForce * (pushRadius - dist) / pushRadius;
          pressureForceX += (dx/dist) * force;
          pressureForceY += (dy/dist) * force;
        }
      }

      // Acceleration = forces / density + gravity in y
      pi.ax = (pressureForceX + viscosityForceX) / pi.density;
      pi.ay = (pressureForceY + viscosityForceY) / pi.density + gravity / canvas.height;
    }
  }

  function integrate() {
    for(let p of particles) {
      p.vx += p.ax * dt;
      p.vy += p.ay * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;

      // Simple boundary conditions
      if(p.x < PARTICLE_RADIUS / canvas.width) {
        p.x = PARTICLE_RADIUS / canvas.width;
        p.vx *= -0.5;
      }
      if(p.x > 1 - PARTICLE_RADIUS / canvas.width) {
        p.x = 1 - PARTICLE_RADIUS / canvas.width;
        p.vx *= -0.5;
      }
      if(p.y < PARTICLE_RADIUS / canvas.height) {
        p.y = PARTICLE_RADIUS / canvas.height;
        p.vy *= -0.5;
      }
      if(p.y > 1 - PARTICLE_RADIUS / canvas.height) {
        p.y = 1 - PARTICLE_RADIUS / canvas.height;
        p.vy *= -0.5;
      }
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'black';
    for(let p of particles) {
      ctx.beginPath();
      ctx.arc(p.x * canvas.width, p.y * canvas.height, PARTICLE_RADIUS, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function loop() {
    computeDensityPressure();
    computeForces();
    integrate();
    draw();
    requestAnimationFrame(loop);
  }

  loop();
})();
</script>
</body>
</html>
