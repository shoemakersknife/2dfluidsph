<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Simple SPH Fluid Simulation (CPU)</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: white;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: white;
      border: 1px solid black;
    }
  </style>
</head>
<body>
<canvas id="canvas" width="600" height="600"></canvas>
<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const NUM_PARTICLES = 1000;
  const PARTICLE_RADIUS = 5;

  const h = 0.06;
  const mass = 1;
  const restDensity = 1000;
  const stiffness = 8000;
  const viscosity = 10000;
  const gravity = 0;
  const damping = 0.98;
  const dt = 0.0001;

  class Particle {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.vx = 0;
      this.vy = 0;
      this.ax = 0;
      this.ay = 0;
      this.density = 0;
      this.pressure = 0;
    }
  }

  const particles = [];
  for (let i = 0; i < NUM_PARTICLES; i++) {
    particles.push(new Particle(
      0.1 + 0.8 * Math.random(),
      0.1 + 0.8 * Math.random()
    ));
  }

  function poly6Kernel(r, h) {
    if (r >= 0 && r <= h) {
      let x = (h * h - r * r);
      return 315 / (64 * Math.PI * Math.pow(h, 9)) * x * x * x;
    }
    return 0;
  }

  function spikyGradKernel(rVec, r, h) {
    if (r > 0 && r <= h) {
      const coeff = -45 / (Math.PI * Math.pow(h, 6)) * (h - r) * (h - r);
      return { x: coeff * (rVec.x / r), y: coeff * (rVec.y / r) };
    }
    return { x: 0, y: 0 };
  }

  function viscosityLapKernel(r, h) {
    if (r >= 0 && r <= h) {
      return 45 / (Math.PI * Math.pow(h, 6)) * (h - r);
    }
    return 0;
  }

  let mouseX = 0.5, mouseY = 0.5;
  let mouseDown = false;

  canvas.addEventListener('mousedown', e => {
    mouseDown = true;
    updateMousePos(e);
  });
  canvas.addEventListener('mouseup', () => {
    mouseDown = false;
  });
  canvas.addEventListener('mousemove', e => {
    if (mouseDown) updateMousePos(e);
  });

  function updateMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    mouseX = (e.clientX - rect.left) / rect.width;
    mouseY = (e.clientY - rect.top) / rect.height;
  }

  function computeDensityPressure() {
    for (let i = 0; i < NUM_PARTICLES; i++) {
      let pi = particles[i];
      let density = 0;
      for (let j = 0; j < NUM_PARTICLES; j++) {
        let pj = particles[j];
        let dx = pj.x - pi.x;
        let dy = pj.y - pi.y;
        let r = Math.sqrt(dx * dx + dy * dy);
        density += mass * poly6Kernel(r, h);
      }
      pi.density = density;
      pi.pressure = stiffness * (density - restDensity);
    }
  }

  function computeForces() {
    for (let i = 0; i < NUM_PARTICLES; i++) {
      let pi = particles[i];
      let pressureForceX = 0;
      let pressureForceY = 0;
      let viscosityForceX = 0;
      let viscosityForceY = 0;

      for (let j = 0; j < NUM_PARTICLES; j++) {
        if (i === j) continue;
        let pj = particles[j];
        let dx = pj.x - pi.x;
        let dy = pj.y - pi.y;
        let r = Math.sqrt(dx * dx + dy * dy);
        if (r < h && r > 0) {
          let grad = spikyGradKernel({ x: dx, y: dy }, r, h);
          let pressTerm = (pi.pressure + pj.pressure) / (2 * pj.density);
          pressureForceX += -mass * pressTerm * grad.x;
          pressureForceY += -mass * pressTerm * grad.y;

          let velDiffX = pj.vx - pi.vx;
          let velDiffY = pj.vy - pi.vy;
          let lap = viscosityLapKernel(r, h);
          viscosityForceX += viscosity * mass * (velDiffX / pj.density) * lap;
          viscosityForceY += viscosity * mass * (velDiffY / pj.density) * lap;
        }
      }

      pi.ax = (pressureForceX + viscosityForceX) / pi.density;
      pi.ay = (pressureForceY + viscosityForceY) / pi.density + gravity / canvas.height;
    }
  }

 /* function applyMouseForce() {
    if (!mouseDown) return;

    const pushRadius = 0.1;
    const pushForce = 50000;

    for (let pi of particles) {
      let dx = pi.x - mouseX;
      let dy = pi.y - mouseY;
      let dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < pushRadius && dist > 0.0001) {
        let force = pushForce * (pushRadius - dist) / pushRadius;
        pi.ax += (dx / dist) * force;
        pi.ay += (dy / dist) * force;
      }
    }
  }*/

  function applyRepulsion() {
    for (let i = 0; i < particles.length; i++) {
      for (let j = i + 1; j < particles.length; j++) {
        const pi = particles[i];
        const pj = particles[j];
        const dx = pj.x - pi.x;
        const dy = pj.y - pi.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const minDist = 0.015;
        if (dist < minDist && dist > 0) {
          const overlap = minDist - dist;
          const pushX = (dx / dist) * overlap * 0.5;
          const pushY = (dy / dist) * overlap * 0.5;
          pi.x -= pushX;
          pi.y -= pushY;
          pj.x += pushX;
          pj.y += pushY;
        }
      }
    }
  }

  function integrate() {
    for (let p of particles) {
      p.vx += p.ax * dt;
      p.vy += p.ay * dt;
      p.vx *= damping;
      p.vy *= damping;
      p.x += p.vx * dt;
      p.y += p.vy * dt;

      if (p.x < PARTICLE_RADIUS / canvas.width) {
        p.x = PARTICLE_RADIUS / canvas.width;
        p.vx *= -0.5;
      }
      if (p.x > 1 - PARTICLE_RADIUS / canvas.width) {
        p.x = 1 - PARTICLE_RADIUS / canvas.width;
        p.vx *= -0.5;
      }
      if (p.y < PARTICLE_RADIUS / canvas.height) {
        p.y = PARTICLE_RADIUS / canvas.height;
        p.vy *= -0.5;
      }
      if (p.y > 1 - PARTICLE_RADIUS / canvas.height) {
        p.y = 1 - PARTICLE_RADIUS / canvas.height;
        p.vy *= -0.5;
      }
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'black';
    for (let p of particles) {
      ctx.beginPath();
      ctx.arc(p.x * canvas.width, p.y * canvas.height, PARTICLE_RADIUS, 0, Math.PI * 2);
      ctx.fill();
    }

    // Optional: Draw mouse pointer
    /*if (mouseDown) {
      ctx.beginPath();
      ctx.arc(mouseX * canvas.width, mouseY * canvas.height, 10, 0, Math.PI * 2);
      ctx.fillStyle = 'red';
      ctx.fill();
    }*/
  }

  function loop() {
    computeDensityPressure();
    computeForces();
   // applyMouseForce();     // <- mouse force applied separately
    integrate();
    applyRepulsion();
    draw();
    requestAnimationFrame(loop);
  }

  loop();
})();
</script>
</body>
</html>
